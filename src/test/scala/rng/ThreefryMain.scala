// See README.md for license details.
//
// package rial.rng
//
// import chisel3._
// import scopt.OptionParser
//
// /**
//   * This provides an alternate way to run tests, by executing then as a main
//   * From sbt (Note: the test: prefix is because this main is under the test package hierarchy):
//   * {{{
//   * test:runMain pipe.RSquareMain
//   * }}}
//   * To see all command line options use:
//   * {{{
//   * test:runMain pipe.RSquareMain --help
//   * }}}
//   * To run with verilator:
//   * {{{
//   * test:runMain pipe.RSquareMain --backend-name verilator
//   * }}}
//   * To run with verilator from your terminal shell use:
//   * {{{
//   * sbt 'test:runMain pipe.RSquareMain --backend-name verilator'
//   * }}}
//   */
// object ThreefryMain extends App {
//   val (arg0, arg1) = rial.util.ScalaUtil.separateOptions(args)
//
//   case class Config(ncycle:Int=100)
//
//   val parser = new scopt.OptionParser[Config]("Threefry") {
//     head("scopt", "3.x")
//     opt[Int]('n', "ncycle") action { (x, c) =>
//       c.copy(ncycle = x) } text("ncycle is the number of simulation cycles")
//   }
//
//   parser.parse(arg1, Config()) map { config =>
//     val ncycle = config.ncycle
//     println(f"ncycle=$ncycle")
//     iotesters.Driver.execute(arg0, () => new Threefry4_32(20, 0) ) {
//       c => new ThreefryUnitTester(c, ncycle)
//     }
//   }
// }

// /**
//   * This provides a way to run the firrtl-interpreter REPL (or shell)
//   * on the lowered firrtl generated by your circuit. You will be placed
//   * in an interactive shell. This can be very helpful as a debugging
//   * technique. Type help to see a list of commands.
//   *
//   * To run from sbt
//   * {{{
//   * test:runMain pipe.RSquareRepl
//   * }}}
//   * To run from sbt and see the half a zillion options try
//   * {{{
//   * test:runMain pipe.RSquareRepl --help
//   * }}}
//   */
// object ThreefryRepl extends App {
//   iotesters.Driver.executeFirrtlRepl(args, () => new Threefry4_32(20, 0))
// }
